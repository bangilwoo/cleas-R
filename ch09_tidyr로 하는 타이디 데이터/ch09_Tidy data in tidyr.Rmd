---
title: "tidyr로 하는 타이디 데이터"
author: "Bangilwoo"
output:
  html_document:
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 9.1 들어가기

데이터 분석가들은 흔히 데이터를 정제하고 준비하는 데 전체 분석 시간 중 80%를 쓴다고 말한다.

타이디(tidy, 깔끔한) 데이터는 데이터를 일관성 있게 정리해준다. tidyvers의 패키지에 있는 타이디 데이타와 도구를 사용하면 데이터를 기존 표현법에서 다른 표현법으로 더 짧은 시간 안에 처리해 분석 문제를 다루는 일에 더 많으 시간을 쓸 수 있게 된다.

### 9.1.1 준비하기

tidyr은 tidyverse에 포함되어 있으므로 해당 패키지가 설치 되어있지 않다면 우선 설치한다.
tidyr만 단독으로 사용하고 싶다면 tidyr 패키지만 설치해줘도 된다.

**install.packages("tidyverse")**
**install.packages("tidyr")**

```{r message=FALSE}
library(tidyverse)
library(tidyr) # tidyr만 설치 했을 경우
```

## 9.2 타이디 데이터

하나의 기본 데이터를 표현하는 방식은 다양하다. 각 데이터셋은 국가, 연도, 인구, 사례수의 값을 동일하게 보여 주지만 다른 방식으로 구현 된다.

```{r}
table1
table2
table3
# 티블 두개로 펼쳐짐
table4a # 사례수
table4b # 인구
```

모두 같은 데이터를 표현하지만, 사용성이 같지는 않다. 타이디 데이터셋만이 tidyvers 내부에서 작업하기 훨씬 쉽게 한다.<br>
데이터셋을 타이디하게 만드는, 서로 연관된 세가지 규칙

**1.변수마다 해당되는 열이 있어야 한다.**  
**2.관측값마다 해당되는 행이 있어야 한다**    
**3.값마다 해당하는 하나의 셀이 있어야한다**

위의 3가지 규칙들은 서로 연관되어 있어, 셋중 두가지만 충족시키는것은 불가능하다. 이 상호관계 때문에 아래와 같은 간단하고 실용적이 지침이 도출된다.

**1.데이터셋을 티블에 각각 넣어라**
**2.변수를 열에 각각 넣어라**

위의 예에서는 table1만 타이디하다. 이 테이블만이 각 열이 변수인 표현이다.

데이터가 타이디할때의 주요장점 두가지

- **데이터를 일괄된 방식으로 저장하면 보편적인 장점이다. 일관된 데이터 구조를 사용하면 이에 적용할 도구들이 공통성을 가지게 되어, 이들을 배우기가 쉬워진다.**
- **변수를 열에 배치하면 R의 벡터화 속성이 가장 잘 발휘된다는 점에서 구체적인 장점이 생긴다. 대부분의 내장 R함수는 벡터에 작동한다. 이러한 성질 때문에 타이디 데이터로 작업하는 것이 더 자연스럽게 된다.**

dplyr, ggplot2를 비롯한 tidyvers의 모든 패키지는 타이디 데이터로 동작하도록 설계되었다. 다음의 예제를 확인해 보자.

```{r}
# 10,000명 당 비율 계산
table1 %>% 
  mutate(rate= cases / population * 10000)

#연간 사례 수 계산
table1 %>%
  count(year, wt= cases)

#시간에 따른 변화 시각화
library(ggplot2)
ggplot(table1, aes(year, cases)) +
  geom_line(aes(group= country), color= "grey50") +
  geom_point(aes(color= country))
```

### 9.3 Gather()와 Spread()

모든 데이터는 타이디 하게 보이지만 그렇지 않은 데이터셋을 볼일이 생긴다. 그 이유는 이래와 같다.

- 대부분의 사람은 타이디 데이터의 원리에 익숙하지 않으며 데이터를 타이디하게 만드는데 시간을 쓰지않는다.
- 데이터는 분석보다는 다른 용도에 편리하도록 구성되는 경우가 더 많다

따라서 실제 분석에서는 데이터를 깔끔하게 정리하는작업이 필요하다. 첫번째 단계는 항상 변수롸 관측값이 무엇인지 파악하는 것이고, 두번째 단계는 자주 일어나는 다음의 두가지 문제 중 하나를 해결하는 것이다.

- 하나의 변수가 여러 열에 분산되어 있을 수 있다.
- 하나의 관측값이 여러 행에 흩어져 있을 수 있다.

위와 같은 문제가 발생할 경우 tidyr에서 가장 중요한 두가지 함수(gather, spread)가 필요하다.

### - 9.3.1 Gather()로 모으기

자주 생기는 문제는 데이텃셋의 일부 열 이름이 변수 이름이 아니라 변수 값인 경우이다. table4를 보면 열 이름 1999와 2000은 year 변수 값을 나타내며, 각행은 하나가 아닌 두개의 관측값을 나타낸다.

```{r}
table4a
```

이같은 데이터셋을 깔끔하게 정리하려면 해당 열을 새로운 두 변수로 모아야한다. 이를 위해 세가지 파라미터가 필요하다  

- **변수가 아니라 값을 나타내는 열 집합, 여기에서는 열 1999와 열 2000이다.**  
- **열 이름 자리에 나타난 변수 이름, key라고 부르며 여기에서는 year이다.**  
- **셀에 값이 분산되어 있는 변수 이름, value라고 부르며 여기에서는 cases이다.**  

위와 같은 파라미터와 함께 gather() 호출을 생성할 수 있다.

```{r}
table4a %>%
  gather('1999', '2000', key = "year", value = "cases")
```

수집하고자 하는 열을 지정하는 법은 dplyr::select() 스타일 표기법을 따른다. 두개의 열만 있으므로 개별적으로 나열한다. '1999', '2000'은 구문론적 이름이 아니므로 역따옴표로 둘러쌓아야 함을 주의하자.<br>
최종 결과에서, 수집된 열은 삭제되고 key와 value 열이 생성된다. 원래 변수 간의 관계는 보존된다. table4를 비슷한 방법으로 타이디하게 할 때 gather()를 사용할 수 있다. 유일한 차이점은 셀 값에 저장된 변수이다.

```{r}
table4b %>%
  gather('1999', '2000', key = "year", value = "population")
```

table4a와 table4b의 타이디하게 된 버전을 하나의 티블로 결합하려면 dplyr::left_join()을 사용해야 한다.

```{r}
tidy4a <- table4a %>%
  gather('1999', '2000', key = "year", value = "cases")
tidy4b <- table4b %>%
  gather('1999', '2000', key = "year", value = "population")
left_join(tidy4a, tidy4b)
```

### 9.3.2 Spread()로 펼치기

펼치기는 수집하기의 반대이다. 관측값이 여러 행에 흩어져있을 때 사용한다. 확인을 위해 ggplot2를 보자. 하나의 관측값은 한 해, 한 국가에 대한 것이지만 각 관측값이 두 행에 흩어져 있다.

```{r}
table2
```

이것을 정리하기위해, 먼저 Gather()와 비슷한 방식으로 표현방식을 분석한다. 이번에는 파라미터가 두개만 필요하다.

- **변수 이름을 포함하는 열, 즉 key열. 여기에서는 type이다.**  
- **여러 변수를 형성하는 값을 포함하는 열, 즉 value열, 여기에서는 count이다.**  

파라미터를 정하면 spread()를 사용할 수 있다. 

```{r}
table2 %>%
  spread(key = type, value = count)
```

공통의 key와 value 인수를 통해 추측해 본 사람도 있겠지만 spread()와 gather()는 보완관계이다. gather()는 넓은 테이블을 더 좁고 길게, spread()는 긴 테이블을 더 짧고 넓게 만든다.

## 9.4 Separate()와 Unite()

지금까지 table2와 table4를 정리했지만 table3은 정리하지 않았다. table3에는 다른 문제가 있다. 두개의 변수(cases, poplation)가 포함된 한개의 열이 있다. 이 문제를 해결하려면 separate()함수가 필요하다. 또 한 하나의 변수가 여러 열에 분산되어 있는 경우에 사용하는, seoarate()의 보완함수인 unite()에 대해서 학습한다.

### 9.4.1 separate()로 분리하기

separate()는 구분 문자가 나타나는 곳마다 쪼개서 하나의 열을 여러 열로 분리한다.

```{r}
table3
```

rate열은 cases와 population변수를 모두 포함하므로 두 변수로 쪼개야 한다. separate()는 분리할 열 이름과, 분리하여 만들 열 이름을 필요로 한다.

```{r}
table3 %>%
  separate(rate, into = c("cases", "population"))
```

기본적으로 separate()는 슛자나 글자가 아닌 문자를 볼 때마다 값을 쪼갠다. 예를 들어 앞의 코드에서 separate()는 슬래시 문자로 rate값을 쪼갠다. 특정 문자를 사용하여 열을 구분하려면 이를 separate()의 sep인수로 전달하면 된다. 예를 들어 이전 코드를 다시 작성할 수 있다.

```{r}
table3 %>%
  separate(rate, into = c("cases", "population"), sep="/")
```

cases와 population은 문자형 열이라는 것을 알았을 것이다. 이는 separate()의 기본 동작이다. 즉, 열의 유형을 그대로 유지한다. 그러나 이들이 사실은 숫자이므로 기본 동작이 유용하지는 않다. convert= TRUE를 하면 separate()이 도 나은 유형으로 변형을 시도한다.

```{r}
table3 %>%
  separate(
    rate, 
    into = c("cases", "population"),
    convert= TRUE
    )
```

sep에 정수 벡터를 전달할 수도 있다. seprate()는 이 정수를 쪼갤 위치로 해석할 것이다. 양수 값은 문자열의 가장 왼쪽에서 1부터 시작한다. 음수 값은 문자열의 맨 오른쪽에서 -1부터 시작한다. 정수를 사용하여 문자열을 분리할 때 sep의 길이는 into의 이름 개수보다 하나 작아야 한다.<br>
이 배열을 사용하여 각 연도의 마지막 두 자리를 분리할 수 있다. 이렇게 하면 이 데이터가 덜 깔끔하게 되지만, 어떤 경우에는 유용하다.
  
```{r}
table3 %>%
  separate(year, into =c("century", "year"), sep = 2)
```

### 9.4.2 Unite()로 결합하기

unite()는 separate()의 반대이다. 여러 열을 하나의 열로 결합한다. separate() 보다 드물게 사용하지만, 유용한 도구이다. <br>
unite()를 사용하여 마지막 예제에서 만든 century열과 year열을 합칠 수 있다. 이 데이터는 tidyr::table5로 저장되어 있다. unite()는 데이터프레임, 생성할 새 변수의 이름 및 결합할 열 집합을 필요로 한다.

```{r}
table5 %>%
  unite(new, century, year)
```

이 경우 sep 인수도 사용해야 한다. 기본 설정은 다른 열의 값 사이에 언더스코'_'를 붙이는 것이다. 여기서는 분리 기호를 원하지 않으므로 ""을 사용한다.

```{r}
table5 %>%
  unite(new, century, year, sep= "")
```

## 9.5 결측값

데이터셋의 표현 방식을 변경하면 결측값에도 변화가 생긴다. 데이터값은 아래의 두가지 방식으로 결측될 수 있다.

- **명시적 ,NA로 표시**  
- **암묵적 ,데이터x**  

```{r}
stocks <- tibble(
  year   = c(2015, 2015, 2015, 2015, 2016, 2016, 2016),
  qtr    = c(   1,    2,    3,    4,    2,    3,    4),
  return = c(1.88, 0.59, 0.35,   NA, 0.92, 0.17, 2.66)
)
```

이 데이터셋에는 두가지 결측값이 있다.

- 2015년 4분기 수익은 명백하게 결측되어 있다. 값이 있어야 할 셀에 NA가 존재
- 2016년 1분기 수익은 암묵적으로 결측되었다. 데이터x

데이터셋 표현법으로 암묵적 값을 명시적으로 만들 수 있다. 예를 들어 연도를 열로 넣어 암묵적 결측값을 명시적으로 만들 수 있다.

```{r}
stocks %>%
  spread(year, return)
```

명시적 결측값은 어떤 데이터에서는 중요하지 않을 수 있으므로 gather()에서 na.rm = TRUE를 설정하여 명시적 결측값을 암묵적으로 변경할 수 있다. # na.rm=T 암묵적, na.rm=F모두 표시

```{r}
stocks %>%
  spread(year, return) %>%
  gather(year, return, '2015':'2016', na.rm = T)
```

타이디 데이터에서 결측값을 명시적으로 표현하는 중요한 도구로 complete()도 있다.

```{r}
stocks %>%
  complete(year, qtr)
```

complete()는 열 집합을 입력으로 하여, 고유한 조합을 모두 찾는다. 그후 원본 데이터셋에 모든 값이 포함되로록 필요한 곳에 명시적 NA를 채운다. <br>
결측값 작업할 때 알아야 할 중요한 도구가 하나 더 있다. 데이터 소스가 주로 데이터 입력에 사용된 경우 결측값은 이전 값이 전달되어야 함을 나타낸다.

```{r}
treatment <- tribble(
  ~ person,         ~treatment, ~response,
  "Derrick Whitmore", 1,         7,
  NA,                2,         10,
  NA,                3,         9,
  "Katherine Burke", 1,         4
)
```

이러한 결측값은 fill()을 사용하여 채울 수 있다. 이 함수는 결측갑을 가장 최근의 비결측값으로 치환하고자 하는 열(집합)을 입력으로 한다.(마지막 관측값 이월이라고도 한다.)

```{r}
treatment %>%
  fill(person)
```

이와같이 가장 최근의 값으로 결측치가 채워진것을 볼 수 있다

## 9.6 사례연구

지금까지 배운것을 정리해보자. **tidyr::who** 데이터셋에는 결핵 사례가 연도,국가,나이,성별 및 진단방법별로 세분화되어 있다.<br>  
이 데이터셋에는 역학정보가 풍부하게 있지만, 제공된 데이터로 작업을 하는것은 쉽지않다  

```{r}
tidyr::who
```

이 데이터가 전형적으로 만나게될 데이터의 표본이다. 열 중복, 이상한 가변 코드 및 다수의 결측값이 있다. 
즉, who데이터는 지저분해서 여러 단계를 통해 타이디하게 만들어야 한다. 일반적으로 여러 동사를 파이프라인으로 함께 연결해야 한다.<br>
처음은 변수가 아닌 열을 모으는것으로 시작하는것이 좋다. 다음을 살펴보자.

- **country와 iso2, iso3은 국가를 중복해서 지정하는 세 개의 변수**  
- **year는 연도를 나타낸 변수**  
- **다른 열은 아직 알 수 없지만 new_sp_m014등의 구조를 보면 이들은 변수가 아닌 값이다**

따라서 new_sp_m014부터 newrel_f65까지의 모든 열을 모을 필요가 있다. 값이 무엇을 나타내는지 아직 모르므로 'key'라는 일반적인 이름을 붙이고 셀이 사례 수를 나타내는 것을 알고 있으므로 변수 cases를 사용한다. 현재 결측값이 많으므로 na.rm을 사용하여 있는값만 집중할 것이다

```{r}
who1 <- who %>%
  gather(
    new_sp_m014:newrel_f65, key = "key",
    value = "cases",
    na.rm = TRUE
  )
who1
```

새로운 key 열의 값을 세어서 값의 구조에 대한 힌트를 얻을 수 있다.

```{r}
who1 %>%
  count(key)
```

데이터 사전을 이용하여 형식을 파악할 수 있다.

**?who**

1. 각 열의 처음 세 글자는 해당 열이 포함하는 결핵 사례가 새로운 사례인지 과거 사례인지를 나타낸다. 이 데이터셋에서 각 열은 새로운 사례를 포함한다.
2. 다음 두 글자는 다음의 결핵의 유형을 기술한다.

- rel은 재발 사례를 의미
- ep는 폐외 결핵 사례를 의미
- sn은 폐 얼룩으로 보이지 않는 폐결핵의 사례를 의미
- sp는 폐 얼룩으로 보이는 폐결핵 사례를 의미

3. 여섯 번째 글자는 결핵 환자의 성별을 나타낸다. 남성, 여성으로 사례를 분류 한다.
4. 나머지 숫자는 연령대를 나타낸다. 다음의 7개 연력대로 구분한다.

- 014 = 0-14세
- 1524 = 15-24세
- 2534 = 25-34세
- 3544 = 35-44세
- 4554 = 45-54세
- 5564 = 55-64세
- 65 = 65세 이상

열 이름의 형식을 약간 수정해야 한다. 열 이름이 new_rel이 아니라 newrel이기 때문에 이름에 일관성이 없다. 'newrel' 문자를 'new_rel'문자로 바꾼다. 이렇게 하면 모든 변수 이름에서 일관성이 유지된다.

```{r}
who2 <- who1 %>%
  mutate(key = stringr::str_replace(key, "newrel", "new_rel"))
who2
```

각 코드의 값을 separate() 2회 실행하면 분리할 수 있다. 첫번재 실행은 각 언더 스코어마다 코드를 조갠다.

```{r}
who3 <- who2 %>%
  separate(key, c("new", "type", "sexage"), sep ="_")
who3
```

new열은 이 데이터셋에서 상수이므로 제거할 수 있다. iso2와 iso3도 중복이므로 함께 제거하자.

```{r}
who3 %>%
  count(new)

who4 <- who3 %>%
  select(-new, -iso2, -iso3)
```

마지막으로 성별나이 열을 성별, 나이로 분리한다.

```{r}
who5 <- who4 %>%
  separate(sexage, c("sex", "age"), sep = 1)
who5
```

## 9.7 타이디하지 않은 데이터

다른 주제로 넘어 가기 전에 타이디하지 않은 데이터에 대해 간단히 이야기 해보자. 이 장의 앞부분에서 타이디하지 않은 데이터를 의미하기 위해 부정적인 용어인 ’지저분한’을 사용했다. 이는 과도하게 단순화한 것이다. 타이디 데이터가 아니더라도 유용하고 잘 구성된, 많은 데이터 구조가 있다. 다른 데이터 구조를 사용하는 데는 주된 이유가 두 가지이다.

 - 다른 표현 방식이 성능상, 저장용량상 장점이 클 수 있다.
 - 전문 분야에서 독자적으로 발전시킨 데이터 저장 규칙이 타이디 데이터의 규칙과 다를 수 있다.
 
이런 이유로 인해 티블(또는 데이터프레임)이 아닌 다른 것이 필요해진다. 데이터가 관측값과 변수로 구성된 구조에 자연스럽게 맞아떨어진다면 타이디 데이터가 기본 선택이어야 한다고 생각한다. 그러나 다른 구조를 사용하는 데도 그럴만한 충분한 이유가 있다. 타이디 데이터만이 유일한 방법은 아니다.
