---
title: "ch09_tidyr로 하는 타이디 데이터"
author: "Bangilwoo"
output:
  html_document:
   toc : true
   toc_float : true
   toc_depth : 3
---
Tidy data in tidyr
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### 9.1 들어가기
**데이터 분석가들은 흔히 데이터를 정제하고 준비하는 데 전체 분석 시간 중 80%를 쓴다고 말한다**  
(It is often said that 80% of data analysis is spent on the cleaning and preparing data).

타이디 데이터는 tidy, 즉 깔끔한 데이터라는 뜻이다  
tidyr은 tidyverse 패키지에 포함되어있는 도구이다   
타이디 데이터와 tidyr을 사용하면 데이터를 기존의 표현법에서 다른 표현법으로 훨씬 빠르게   
처리할 수 있고 이말은 분석에 시간을 더 쓸 수 있게 된다는것이다  
9장에서는 타이디 데이터에 대해 실무적으로 소개하고 tidyr에 포험된 도구의 사용법을 살펴본다


### - 9.1.1 준비하기
tidyr은 tidyverse에 포함되어 있으므로 해당 패키지가 설치 되어있지않다면 우선 설치한다 

**install.packages("tidyverse")**

tidyr만 단독으로 사용하고 싶다면 tidyr 패키지만 설치해줘도 된다

**install.packages("tidyr")**

그리고 설치한 tidyverse 패키지를 활성화 시켜준다

```{r message=FALSE}
library(tidyverse)
```

tidyr만 설치 했을 시에는

**library(tidyr)**


### 9.2 타이디 데이터

다음 예는 같은 데이터를 다른 4가지 방식으로 구성한것이다
```{r}
tidyr::table1
tidyr::table2
tidyr::table3
tidyr::table4a
tidyr::table4b
```

각 데이터셋은 country(국가), year(연도), population(인구), cases(사례 수)의 값을 동일하게 보여주지만  
다른방식으로 구성되었다

데이터셋을 깔끔하게 만드는, 서로 연관된 세 가지 규칙을 tidyr에서는  
다음과 같이 말하고 있다

**1.변수마다 해당되는 열이 있어야 한다.**  
**2.관측값마다 해당되는 행이 있어야 한다**    
**3.값마다 해당하는 하나의 셀이 있어야한다**

위의 3가지 규칙들은 서로 연관되어 있어, 셋중 두가지만 충족시키는것은 불가능하다

조금 더 쉽게 말하자면 보통 표를 그릴 때 크게 두가지 방식중 하나를 쓸 수 있다는것을 생각하면 된다 

예를 들어 다섯사람이 서로 친구인지 아닌지 표를 그린다는 가정하에 아래의 두가지 방식이 가능하다

![](./wide-long.png)

각각 와이드, 롱 포맷이라 부른다
와이드는 옆으로 넓게 퍼지고 롱은 아래로 길게 늘어지는 형태로 나타난다


### 9.3 Gather()와 Spread()

모든 데이터가 타이디하게 정리가 되어있지않은지 의문이 들텐데 현실은 불행하게도 그렇지 않을것이다

이유는 크게 두가지인데  
- 대부분의 사람은 타이디 데이터의 원리에 익숙하지 않으며 데이터를 타이디하게 만드는데 시간을 쓰지않는다  
- 데이터는 분석보다는 다른 용도에 편리하도록 구성되는 경우가 더 많다

따라서 실제 분석에서는 데이터를 깔끔하게 정리하는작업이 필수이다

이때 사용되는 두가지 중요한 함수가 Gather()와 Sperad()이다

### - 9.3.1 Gather()로 모으기
자주 생기는 문제가 데이터셋의 일부 열 이름이 변수 이름이 아니라 변수 값인 경우이다  
table4a를 보면 열 이름 1999와 2000은 year 변수 값을 나타내며, 각 행은 하나가 아닌 두개의 관측값을 나타낸다 
```{r}
tidyr::table4a
```
이같은 데이터셋을 깔끔하게 정리하려면 해당 열을 새로운 두 변수로 모아야한다  
이를 위해 세가지 파라미터가 필요하다  
  **- 변수가 아니라 값을 나타내는 열 집합, 여기에서는 열 1999와 열 2000**  
  **- 열 이름 자리에 나타난 변수 이름, key라고 부르며 여기에서는 year**  
  **- 셀에 값이 분산되어 있는 변수 이름, value라고 부르며 여기에서는 cases**  

```{r}
table4a %>%
  gather('1999', '2000', key = "year", value = "cases")
```
같은 방법으로 table4b도 정리가 가능하다

```{r}
table4b %>%
  gather('1999', '2000', key = "year", value = "population")
```
### - 9.3.2 Spread()로 펼치기

펼치기는 모으기의 반대이다  
관측값이 여러 행에 흩어져있을 때 사용한다  
예를들어 table2를 보면 
```{r}
tidyr::table2
```
한 국가에 대한 한 해 관측값이 두 행에 흩어져있다  
이것을 정리하기위해 먼저 Gather()와 비슷한 방식으로 표현방식을 분석한다
하지만 이번엔 파라미터가 두개만 있어도 된다  
  **- 변수 이름을 포함하는 열 = key열, 여기에서는 type**  
  **- 여러 변수를 형성하는 값을 포함하는 열 = value열, 여기에서는 count**  

파라미터를 정하면 spread()를 사용할 수 있다

```{r}
table2 %>%
  spread(key = type, value = count)
```

공통의 인수를 사용한다는것으로 알 수 있듯 Spread()와 Gather()는 상호보완 관계이다  

### 9.4 Separate()와 Unite()
지금까지 table2와 table4를 정리했지만 table3은 정리하지않았다  
table3의 문제는 두개의 변수가 하나의 열에 합쳐져 있다는것이다   
이문제를 해결하려면 Separate() 함수를 사용하면 된다  
또한 하나의 변수가 여러 열에 분산되어 있는 경우 사용하는 Unite() 함수도 알아보자  

### - 9.4.1 separate()로 분리하기
separate()는 구분문자가 나타나는 곳마다 쪼개서 하나의 열을 여러 열로 분리한다  
table3의 rate열은 cases와 population 변수가 합쳐져있다
해당 열을 쪼개려면 분리하여 만들 열 이름을 지정해주면 된다

```{r}
table3 %>%
  separate(rate, into = c("cases", "population"))
```
하지만 아직 문제가 있다 cases와 population의 열 유형이 문자형열로 설정되어 있다  
이는 열의 유형을 그대로 유지하는 separate()의 기본동작이다
convert = TRUE를 하면 separate()이 더 나은 유형으로 변형한다 #convert 변환

```{r}
table3 %>%
  separate(
    rate, into = c("cases", "population"),
    convert = TRUE
  )
```
sep에 정수 백터를 입력하여 쪼갤수도 있다  
이경우 양수값은 문자열의 가장 왼쪽 1부터, 음수 값은 문자열의 오른쪽 -1부터 시작한다  
정수를 사용하여 문자열을 분리할 때, sep의 길이는 into의 이름개수보다 하나 작아야한다  

```{r}
table3 %>%
  separate(year, into =c("century", "year"), sep = 2)
```
잘 쓰이지는 않지만 어떤 경우에는 유용하다


### - 9.4.2 Unite()로 결합하기
unite()는 separate()의 반대이다    
여러 열을 하나의 열로 결합한다    
separate()보다는 드물게 필요하지만 유용하다  

unite()를 사용하여 마지막 예제에서 만든 century열과 year열을 합칠 수 있다  
해당 데이터는 table5에 저장되어있다
```{r}
tidyr::table5
```
unite()를 사용하면

```{r}
table5 %>%
  unite(new, century, year)
```
다음과 같은 결과가 나온다  
기본 설정은 합친 열의 값 사이에 언더바(_)를 붙이는 것이다  
해당 기호가 필요하지 않으면 sep에 ""를 주어 삭제 할 수 있다
```{r}
table5 %>%
  unite(new, century, year, sep ="")
```

### 9.5 결측값

데이터셋의 표현 방식을 변경하면 결측값에도 변화가 생긴다  
데이터값은 다음의 두가지 방식으로 결측될 수 있다  
  **-명시적 ,NA로 표시**  
  **-암묵적 ,그냥 빈칸**  

```{r}
stocks <- tibble(
  year   = c(2015, 2015, 2015, 2015, 2016, 2016, 2016),
  qtr    = c(   1,    2,    3,    4,    2,    3,    4),
  return = c(1.88, 0.59, 0.35,   NA, 0.92, 0.17, 2.66)
)
```
이 데이터셋에는 두가지 결측값이 있다  
하나는 2015년 4분기의 NA, 다른 하나는 2016 1분기의 데이터이다  

데이터셋 표현법으로 암묵적값을 명시적으로 만들 수 있다
예를 들어 연도를 열로 넣어 결측값을 명시적으로 만들 수 있다 #spread 암묵적값을 명시적값으로 만듬

```{r}
stocks %>%
  spread(year, return)
```

명시적 결측값은 어떤 데이터에서는 중요하지 않을 수 있으므로  
gather()에서 na.rm = TRUE를 설정해서 암묵적 결측값으로 변경할 수 있다 na.rm=T 암묵적, na.rm=F모두 표시

```{r}
stocks %>%
  spread(year, return) %>%
  gather(year, return, '2015':'2016', na.rm = T)
```

타이디 데이터에서 결측값을 명시적으로 표현하는 중요한 도구로 complete()도 있다  
complete()는 열집합을 입력으로 하여, 고유한 조합을 모두 찾는다  
그런 다음 원본 데이터셋에 모든 값이 포함되도록 필요한 곳에 명시적 NA를 채운다 

```{r}
stocks %>%
  complete(year, qtr)
```

fill()은 결측치를 가장 최근의 비결측값으로 채운다
```{r}
treatment <- tribble(
  ~ person,           ~treatment, ~response,
  "Derrick Whitmore", 1,          7,        
  NA,                 2,          10,
  NA,                 3,          9,
  "Katherine Burke",  1,          4
)
```
위의 데이터를 보면 두번째, 세번째의 person 값이 결측값이다  
해당 데이터에 fill()을 사용할 경우

```{r}
treatment %>%
  fill(person)
```
이와같이 가장 최근의 값으로 결측치가 채워진것을 볼 수 있다

### 9.6 사례연구

지금까지 배운것을 정리해보자  
**tidyr::who** 데이터셋에는 결핵 사례가 연도,국가,나이,성별 및 진단방법별로 세분화되어있다  
이 데이터셋에는 역학정보가 풍부하게 있지만, 제공된 데이터로 작업을 하는것은 쉽지않다  

```{r}
tidyr::who
```

이 데이터가 전형적으로 만나게될 데이터의 표본이다  
열 중복, 이상한 가변 코드 및 다수의 결측값이 있다  
즉, who데이터는 너무 지저분해서 여러 단계를 통해 정리해야한다  
처음은 변수가 아닌 열을 모으는것으로 시작하는것이 좋다  
다음을 살펴보자  
**- country와 iso2, iso3은 국가를 중복해서 지정하는 세 개의 변수**  
**- year는 연도를 나타낸 변수**  
**- 다른 열은 아직 알 수 없지만 new_sp_m014등의 구조를 보면 이들은 변수가 아닌 값이다**  
따라서 new_sp_m014부터 newrel_f65까지의 모든 열을 모을 필요가 있다  
이 값이 무엇을 나타내는지 아직 모르므로 'key'라는 일반적인 이름을 붙이고  
사례 수는 'cases'를 사용한다  
현재 결측값이 많으므로 na.rm을 사용하여 있는값만 집중할 것이다

```{r}
who1 <- who %>%
  gather(
    new_sp_m014:newrel_f65, key = "key",
    value = "cases",
    na.rm = TRUE
  )
who1
```

새로운 key 열의 값을 세어서 값의 구조에 대한 힌트를 얻을 수 있다

```{r}
who1 %>%
  count(key)
```

데이터 사전을 이용해 new_sp_m014등의 열이 무엇을 의미하는지 알아보자

**?who**

**데이터 사전은 다음을 알려준다**  
 - 처음의 세글자는 결핵사례가 새로운 사례인지 과거 사례인지 나타낸다(이 데이터셋에서는 새로운 사례만 포함한다)
 - 그다음 두글자는 결핵의 유형을 나타낸다  
 - 여섯번째 글자는 환자의 성별을 나타낸다  
 - 나머지 숫자는 연령대를 나타낸다  
 
 사례중 newrel의 명칭에 일관성이 없으므로 다른 열의 형식에 맞춰서 new_rel로 바꾼다
```{r}
who2 <- who1 %>%
  mutate(key = stringr::str_replace(key, "newrel", "new_rel"))
who2
```

다음으로는 key열의 값을 사례유형, 결핵유형, 성별나이로 분리한다
```{r}
who3 <- who2 %>%
  separate(key, c("new", "type", "sexage"), sep ="_")
who3
```

다음은 필요없는 열을 제거한다  
이 데이터셋에서 new, iso2, iso3은 의미없는 데이터이므로 삭제하는게 가독성이 좋을것이다  
단, 먼저 정말로 new 타입의 데이터 밖에 없는지 확인 후 삭제한다

```{r}
who3 %>%
  count(new)

who4 <- who3 %>%
  select(-new, -iso2, -iso3)
```

마지막으로 성별나이 열을 성별, 나이로 분리한다

```{r}
who5 <- who4 %>%
  separate(sexage, c("sex", "age"), sep = 1)
who5
```

### 9.7 타이디하지 않은 데이터
다른 주제로 넘어 가기 전에 타이디하지 않은 데이터에 대해 간단히 이야기 해보자    
이 장의 앞부분에서 타이디하지 않은 데이터를 의미하기 위해 부정적인 용어인 ’지저분한’을 사용했다    
이는 과도하게 단순화한 것이다. 타이디 데이터가 아니더라도 유용하고 잘 구성된, 많은 데이터 구조가 있다     
다른 데이터 구조를 사용하는 데는 주된 이유가 두 가지이다  
 - 다른 표현 방식이 성능상, 저장용량상 장점이 클 수 있다  
 - 전문 분야에서 독자적으로 발전시킨 데이터 저장 규칙이 타이디 데이터의 규칙과 다를 수 있다  
이런 이유로 인해 티블(또는 데이터프레임)이 아닌 다른 것이 필요해진다   
데이터가 관측값과 변수로 구성된 구조에 자연스럽게 맞아떨어진다면 타이디 데이터가 기본 선택이어야 한다고 생각한다   
그러나 다른 구조를 사용하는 데도 그럴만한 충분한 이유가 있다   
타이디 데이터만이 유일한 방법은 아니다.
